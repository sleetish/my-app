import pytest
from unittest.mock import patch, MagicMock
import sys
import os
from io import StringIO
# Import the main function from your CLI script
# This requires cli.py to be importable, e.g., not just using if __name__ == "__main__" for main logic
# Ensure cli.py can be imported (e.g., by being in PYTHONPATH or via relative imports if structured as a package)
from ai_code_platform.cli import main as cli_main
from ai_code_platform.llm_code_generator.llm_service import LLMConfigurationError, LLMAPIError


# Fixture to mock ClaudeService constructor
@pytest.fixture
def mock_claude_service_constructor():
    with patch('ai_code_platform.cli.ClaudeService') as mock_constructor:
        mock_instance = MagicMock()
        mock_instance.generate_code.return_value = "Generated by Mocked Claude"
        mock_constructor.return_value = mock_instance
        yield mock_constructor

# Fixture to mock LocalLLMService constructor
@pytest.fixture
def mock_local_llm_service_constructor():
    with patch('ai_code_platform.cli.LocalLLMService') as mock_constructor:
        mock_instance = MagicMock()
        mock_instance.generate_code.return_value = "Generated by Mocked Local LLM"
        mock_constructor.return_value = mock_instance
        yield mock_constructor


def run_cli_in_test(args_list):
    """Helper to run cli_main by patching sys.argv and capturing output."""
    original_argv = sys.argv
    original_stdout = sys.stdout
    original_stderr = sys.stderr

    sys.argv = ['cli.py'] + args_list
    captured_stdout = StringIO()
    sys.stdout = captured_stdout
    captured_stderr = StringIO()
    sys.stderr = captured_stderr

    exit_code = 0
    try:
        cli_main()
    except SystemExit as e:
        exit_code = e.code
    except Exception as e: # Catch any other unexpected error during CLI execution
        # print(f"CLI execution failed: {e}\n{traceback.format_exc()}", file=sys.stderr)
        # For tests, we might want to let it propagate or specifically check stderr
        sys.stderr.write(f"CLI CRASHED: {e}") # Ensure it goes to our captured_stderr
        exit_code = -1 # Indicate a crash different from sys.exit codes
    finally:
        sys.argv = original_argv
        sys.stdout = original_stdout
        sys.stderr = original_stderr

    return exit_code, captured_stdout.getvalue(), captured_stderr.getvalue()


def test_cli_help_message():
    """Test that the CLI shows a help message."""
    exit_code, stdout, stderr = run_cli_in_test(["--help"])
    assert exit_code == 0
    assert "usage: cli.py [-h]" in stdout
    assert "Generate code using an LLM." in stdout
    assert "--service {claude,local}" in stdout
    assert stderr == ""

def test_cli_claude_service_called(mock_claude_service_constructor):
    """Test CLI calls ClaudeService when specified."""
    prompt = "test prompt for claude"
    mock_claude_instance = mock_claude_service_constructor.return_value # This is the instance the CLI will use

    exit_code, stdout, stderr = run_cli_in_test([prompt, "--service", "claude", "--api-key", "fakekey"])

    assert exit_code == 0, f"CLI Error: {stderr}"
    assert "Generated by Mocked Claude" in stdout
    # Import ClaudeService here to access its DEFAULT_MODEL for the assertion
    from ai_code_platform.llm_code_generator.claude_service import ClaudeService
    mock_claude_instance.generate_code.assert_called_once_with(prompt, "python")
    mock_claude_service_constructor.assert_called_once_with(api_key="fakekey", model=ClaudeService.DEFAULT_MODEL)


def test_cli_local_service_called(mock_local_llm_service_constructor):
    """Test CLI calls LocalLLMService by default and when specified."""
    prompt = "test prompt for local"
    mock_local_instance = mock_local_llm_service_constructor.return_value

    # Test default
    exit_code_default, stdout_default, stderr_default = run_cli_in_test([prompt])
    assert exit_code_default == 0, f"CLI Error (default): {stderr_default}"
    assert "Generated by Mocked Local LLM" in stdout_default
    mock_local_instance.generate_code.assert_called_with(prompt, "python")

    mock_local_instance.reset_mock()
    mock_local_llm_service_constructor.reset_mock()

    # Test explicit --service local
    exit_code_explicit, stdout_explicit, stderr_explicit = run_cli_in_test([prompt, "--service", "local"])
    assert exit_code_explicit == 0, f"CLI Error (explicit): {stderr_explicit}"
    assert "Generated by Mocked Local LLM" in stdout_explicit
    mock_local_instance.generate_code.assert_called_once_with(prompt, "python")


def test_cli_language_parameter(mock_local_llm_service_constructor):
    """Test that the language parameter is passed to the service."""
    prompt = "js prompt"
    language = "javascript"
    mock_local_instance = mock_local_llm_service_constructor.return_value

    exit_code, _, stderr = run_cli_in_test([prompt, "--language", language])
    assert exit_code == 0, f"CLI Error: {stderr}"
    mock_local_instance.generate_code.assert_called_once_with(prompt, language)


def test_cli_claude_model_parameter(mock_claude_service_constructor):
    """Test that claude_model parameter is passed to ClaudeService."""
    prompt = "claude model test"
    model_arg = "claude-test-model"

    exit_code, _, stderr = run_cli_in_test([prompt, "--service", "claude", "--claude-model", model_arg, "--api-key", "dummy"])
    assert exit_code == 0, f"CLI Error: {stderr}"
    mock_claude_service_constructor.assert_called_once_with(api_key="dummy", model=model_arg)


def test_cli_local_url_and_model_parameters(mock_local_llm_service_constructor):
    """Test local_url and local_model parameters are passed to LocalLLMService."""
    prompt = "local params test"
    url_arg = "http://testhost:1234/v1"
    model_arg = "local-test-model"

    exit_code, _, stderr = run_cli_in_test([prompt, "--service", "local", "--local-url", url_arg, "--local-model", model_arg])
    assert exit_code == 0, f"CLI Error: {stderr}"
    mock_local_llm_service_constructor.assert_called_once_with(api_base_url=url_arg, model=model_arg, api_key="not-needed")


def test_cli_claude_configuration_error(mock_claude_service_constructor):
    """Test CLI handles LLMConfigurationError from ClaudeService."""
    # Configure the constructor mock to raise an error when called
    expected_error_msg = "Test Claude config error ANTHROPIC_API_KEY"
    mock_claude_service_constructor.side_effect = LLMConfigurationError(expected_error_msg)

    prompt = "config error test"
    exit_code, _, stderr = run_cli_in_test([prompt, "--service", "claude"]) # No API key, constructor will be called

    assert exit_code == 1 # sys.exit(1) is called by CLI
    assert f"Configuration Error: {expected_error_msg}" in stderr
    assert "Hint: Set the ANTHROPIC_API_KEY" in stderr


def test_cli_local_llm_api_error(mock_local_llm_service_constructor):
    """Test CLI handles LLMAPIError from LocalLLMService."""
    mock_local_instance = mock_local_llm_service_constructor.return_value
    expected_error_msg = "Test Local API failed"
    mock_local_instance.generate_code.side_effect = LLMAPIError(expected_error_msg)

    prompt = "api error test"
    exit_code, _, stderr = run_cli_in_test([prompt, "--service", "local"])

    assert exit_code == 1
    assert f"API Error: {expected_error_msg}" in stderr
